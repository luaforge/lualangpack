%parser lua.lexer
%left MULT PLUS MINUS MOD DIVIDE CONCAT END FUNCTION COMMA NAME NEQ LT GT LE AND GE EQ OR
%right EXP ASSIGN LPAREN

///////////////////////////////////////////////////////////////////////////////
///////////////////////////// ABSTRACT SYNTAX /////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

///////////////////////////// CHUNK ///////////////////////////////////////////
%symbol chunk {
	stat s;
	chunk c;
	public chunk( stat a ){ s = a; }
	public chunk( stat a, chunk b ){ s = a; c = b; }
	public void FillScope( LuaScope scope ) { 
	   if( s != null ) {
	      LuaScope nested = new LuaScope( scope );
	      s.FillScope( nested );
	      scope.nested.AddLast( nested );
	   }
	   if( c != null ) {
	      LuaScope nested = new LuaScope( scope );
	      c.FillScope( nested );  
	      scope.nested.AddLast( nested );
	   }
	}
}


///////////////////////////// BLOCK ///////////////////////////////////////////
%symbol block {
	chunk c;
	public block( chunk a ){ c = a; }
	public block(){}
	public void FillScope( LuaScope scope ){
	   if( c != null )
	    c.FillScope( scope );
	}
}


///////////////////////////// UNARY OP ////////////////////////////////////////
%symbol unop {

}


///////////////////////////// BINARY OP ///////////////////////////////////////
%symbol binop {

}


///////////////////////////// FUNCTION CALL ///////////////////////////////////
%symbol functioncall {
   private prefixexp p;
   private arg m_a;
	public functioncall( prefixexp a, arg b ){ p = a; m_a = b; }
	public virtual void FillScope( LuaScope s ){
	   p.FillScope( s );
	   m_a.FillScope( s );
	}
	public Object Eval() {
	   return null;
	}
}


///////////////////////////// FUNCTION NAME ///////////////////////////////////
%symbol funcname {
	public NAME name;
	public funcname( NAME a ){ name = a; }
	public void FillScope( LuaScope scope ){
	}
}


///////////////////////////// PARAM LIST //////////////////////////////////////
%symbol parlist {
	parlist p;
	NAME name;
	public parlist( NAME a ){ name = a; }
	public parlist( NAME a, parlist b ){ name = a; p = b; }
	public void FillScope( LuaScope s ) {
	    if( p != null )
	        p.FillScope( s );
	}
}


///////////////////////////// FUNCTION BODY ///////////////////////////////////
%symbol funcbody {
	block b;
	parlist p;
	END e;
	RPAREN paren;
	public funcbody( block a, END c, RPAREN d ){ b = a; e = c; paren = d; }
	public funcbody( block a, parlist pl, END c, RPAREN d ){ b = a; p = pl; e = c; paren = d; }
	public funcbody( parlist pl, RPAREN d, END c ){ p = pl; paren = d; e = c; }
	public funcbody( RPAREN d, END c ){ paren = d; e = c; } 
	public void FillScope( LuaScope s ){	          
       s.beginLine = paren.Line;
	   s.beginIndx = paren.Position;
	   s.endLine = e.Line;
	   s.endIndx = e.Position + 3;
	   
	   if( b != null ){
	        b.FillScope( s );
	   }
	}
}


///////////////////////////// PREFIX EXPRESSION ///////////////////////////////
%symbol prefixexp {
   private var v;
   private functioncall fc;
   private exp e;
   public prefixexp( var a ){ v = a; }
   public prefixexp( functioncall a ){ fc = a; }
   public prefixexp( exp a ){ e = a; }
   public virtual void FillScope( LuaScope s ){
      if( v != null ){
         v.FillScope( s );
      }
      else if( fc != null ){
         fc.FillScope( s );
      }
      else if( e != null ){
         e.FillScope( s );
      }
   }
   public void FillScope( LuaScope s, var v ) {
      FillScope( s );
   }
   public LuaTable GetTable( LuaScope s ) {
      if( v != null ) {
         return s.Lookup( v.Eval() ); 
      }
      else if( e != null ) {
         return s.Lookup( e.Eval() ); 
      } 
      else if( fc != null ) {
         return s.Lookup( fc.Eval() );
      }
      else {
         return null;
      }
   }
}


///////////////////////////// FIELD ///////////////////////////////////////////
%symbol field {
   private exp e;
   public field( exp a ){ e = a; }
   public virtual void FillScope( LuaScope s ){
      e.FillScope( s );
   }
   public virtual void FillScope( LuaScope s, var v ){
      // v.FieldAssign( s, e.Eval() ); // unstable
   }
}
%node FieldExpAssign : field {
   private exp e1;
   private exp e2;
   public FieldExpAssign( exp a, exp b ){ e1 = a; e2 = b; }
   public override void FillScope( LuaScope s ){
      e1.FillScope( s );
      e2.FillScope( s );
   }
   public override void FillScope( LuaScope s, var v ){
      // TODO: Not sure about this one...   
   }
}
%node FieldAssign : field {
   private NAME n;
   private exp e;
   public FieldAssign( NAME a, exp b ){ n = a; e = b; }
   public override void FillScope( LuaScope s ){
      e.FillScope( s );
   }
   public override void FillScope( LuaScope s, var v ){
      // v.FieldAssign( s, n.s ); // unstable        
   }
}


////////////////////////////// FIELD LIST /////////////////////////////////////
%symbol fieldlist {
   private fieldlist fl;
   private field f;
   public fieldlist( field a, fieldlist b ){ f = a; fl = b; }
   public fieldlist( field a ){ f = a; }
   public virtual void FillScope( LuaScope s ){
      f.FillScope( s );
      
      if( fl != null ){
         fl.FillScope( s );
      }
   }
   public virtual void FillScope( LuaScope s, var v ){
      f.FillScope( s, v );
      
      if( fl != null ){
         fl.FillScope( s, v );
      }
   }
}


////////////////////////////// TABLE //////////////////////////////////////////
%symbol tableconstructor {
   private fieldlist f;
   public tableconstructor( fieldlist a ){ f = a; }
   public virtual void FillScope( LuaScope s ){
      if( f != null ){
         f.FillScope( s );
      }
   }
   public virtual void FillScope( LuaScope s, var v ){
//      v.CreateTable( s );  // Comented for now, causing crashes
      if( f != null ){
         f.FillScope( s, v );
      }
   }
}


////////////////////////////// FUNCTION ///////////////////////////////////////
// Need to make new scope here to cover cases where annon functions are created
// as part of an explist. 
%symbol function {
   private funcbody f;
   public function( funcbody a ){ f = a; } 
   public virtual void FillScope( LuaScope s ){
      LuaScope nested = new LuaScope( s );
	  f.FillScope( nested );
	  s.nested.AddLast( nested );
   }
   public virtual void FillScope( LuaScope s, var v ) {
      f.FillScope( s );   
   }
} 


///////////////////////////// EXPRESSION //////////////////////////////////////
%symbol exp {
   private function f;
   private prefixexp p;
   public exp( function a ){ f = a; }
   public exp( prefixexp a ){ p = a; } 
   public virtual void FillScope( LuaScope s ){
      if( f != null ){
         f.FillScope( s );
      }
      else if( p != null ){
         p.FillScope( s );
      }
   }  
   public virtual void FillScope( LuaScope s, var v ){
      if( f != null ){
         f.FillScope( s, v );
      }
      else if( p != null ){
         p.FillScope( s, v );
      }
   } 
   public virtual Object Eval() {
      return null;
   }
}
%node Binop : exp {
   private exp e1;
   private exp e2;
   private binop b;
   public Binop( exp a, binop b, exp c ){ e1 = a; e2 = c; }
   public override void FillScope( LuaScope s ){
      e1.FillScope( s );
      e2.FillScope( s );
   }
   public override void FillScope( LuaScope s, var v ){
      e1.FillScope( s, v );
      e2.FillScope( s, v );
   }
   public override Object Eval() {
      return null; // TODO: Carry out evaluation           
   }
}
%node Unop : exp {
   private exp e;
   public Unop( unop a, exp b ){ e = b; }
   public override void FillScope( LuaScope s ){
      e.FillScope( s );
   } 
   public override void FillScope( LuaScope s, var v ){
      e.FillScope( s, v );
   } 
   public override Object Eval() {
      return null; // TODO: Carry out evaluation           
   }
}
%node ExpTableDec : exp {
   private tableconstructor t;
   public ExpTableDec( tableconstructor a ){ t = a; }
   public override void FillScope( LuaScope s ){
      t.FillScope( s );
   }
   public override void FillScope( LuaScope s, var v ){
      t.FillScope( s, v );
   }
   public override Object Eval() {
      return t;
   }
} 
%node Atom : exp {
   LITERAL l;
   NUMBER n;
   bool t = false;
   bool nil = false;
   public Atom( LITERAL a ){ l = a; }
   public Atom( NUMBER a ){ n = a; }
   public Atom( FALSE a ){ t = false; }
   public Atom( TRUE a ){ t = true; }
   public Atom( NIL a ){ nil = true; }
   public override Object Eval() {
      if( l != null ) {
         return l;
      }
      else if( n != null ) {
         return n;
      }
      else if( nil ) {
         return null;   
      }
      else {
         return t;
      }
   }
}


///////////////////////////// EXPRESSION LIST /////////////////////////////////
%symbol explist {
   private explist l;
   private exp e;
   public explist( exp a, explist b ){ e = a; l = b; }
   public explist( exp a ){ e = a; }
   public void FillScope( LuaScope s ){
      if( l != null ) {
         l.FillScope( s );
      }
      
      e.FillScope( s );           
   }
   public void FillScope( LuaScope s, varlist v ){
      if( l != null ) {
         l.FillScope( s, v.vl );
      }
      
      e.FillScope( s, v.v );           
   }
}


///////////////////////////// VARIABLE ////////////////////////////////////////
%symbol var {
   private NAME n;
   public var( NAME a ){ n = a; }
   public virtual void FillScope( LuaScope scope ){}
   public virtual void CreateTable( LuaScope s ){
      s.tables.Add(n.s, new LuaTable());   
   }
   public virtual void FieldAssign( LuaScope s, object name ){
      LuaTable t = s.Lookup( n.s );
      t.vals.AddLast( name );
   }
   public virtual Object Eval() {
      return n;
   }
}
%node PackageRef : var {
   private NAME n;
   prefixexp p;
   public PackageRef( prefixexp a, NAME b ){ p = a; n = b; }
   public override void FillScope( LuaScope s ){}
   public override void CreateTable( LuaScope s ){
      LuaTable t = p.GetTable( s );
      if( t != null ){
         t.tables.Add(n.s, new LuaTable());   
      }
   }
   public override void FieldAssign( LuaScope s, object name ){
      LuaTable t = p.GetTable( s );
      if( t != null ){
         t = (LuaTable)t.tables[n.s];
         if( t != null ){
            t.vals.AddLast( name ); 
         }
      }
   }
}
%node TableRef : var {
   prefixexp p;
   exp e;
   public TableRef( prefixexp a, exp b ){ p = a; e = b; }
   public override void FillScope( LuaScope s ){}
   public override void CreateTable( LuaScope s ){
      LuaTable t = p.GetTable( s );
      if( t != null ){
         t.tables.Add(e.Eval(), new LuaTable());     
      }
   }
   public override void FieldAssign( LuaScope s, object name ){
      LuaTable t = p.GetTable( s );
      if( t != null ){
         t = (LuaTable)t.tables[e.Eval()];
         if( t != null ){
            t.vals.AddLast( name ); 
         }
      }
   }  
}


///////////////////////////// VARIABLE LIST ///////////////////////////////////
%symbol varlist {
   public var v;
   public varlist vl;
   public varlist( var a, varlist b ){ v = a; vl = b; }
   public varlist( var a ){ v = a; } 
   public void FillScope( LuaScope scope ) {
      v.FillScope( scope );
      if( vl != null ){
         vl.FillScope( scope );   
      }
   }
}


///////////////////////////// INIT ////////////////////////////////////////////
%symbol init {
    explist e;
    public init( explist a ){ e = a; }
    public void FillScope( LuaScope s ){
        e.FillScope( s );
    }  
}


///////////////////////////// STATMENT ////////////////////////////////////////
%symbol stat {
	public stat(){}
	public virtual void FillScope( LuaScope scope ){} 
}
%node Assignment : stat {
   varlist v;
   explist e;
   public Assignment( varlist a, explist b ){ v = a; e = b; }
   public override void FillScope( LuaScope s ){
      v.FillScope( s );
      e.FillScope( s, v );
   }
}
%node LocalInit : stat {
   namelist n;
   init i;
   public LocalInit( namelist a, init b ){ n = a; i = b; }
   public override void FillScope( LuaScope s ){
      i.FillScope( s );
   }
}
%node Retval : stat {
   private explist e;
   public Retval( explist a ){ e = a; }
   public override void FillScope( LuaScope scope ){
        e.FillScope( scope );
   }
}
%node FuncDecl : stat
{
   funcname fname;
   funcbody body;
   public FuncDecl( funcname a, funcbody b ){ fname = a; body = b; }
   public override void FillScope( LuaScope scope ){
      body.FillScope( scope );
   }
}
%node LocalFuncDecl : stat
{
	funcbody body;
	NAME name;
	public LocalFuncDecl( NAME a, funcbody b ){ name = a; body = b; }
	public override void FillScope( LuaScope scope ){	   
	   body.FillScope( scope );
	}
}
%node FunctionCall : stat
{
    prefixexp p;
    public FunctionCall( prefixexp a ){ p = a; }
    public override void FillScope( LuaScope scope ){	   
	   p.FillScope( scope );
	}  
}
%node SIf : stat
{
    exp e;
    block b;
    public SIf( exp a , block i ){ e = a; b = i; }
    public override void FillScope( LuaScope s ){
        e.FillScope( s );
        b.FillScope( s );
    }
}
%node SElseIf : stat
{
    exp e;
    block b;
    elseif eli;
    public SElseIf( exp a , block i, elseif j ){ e = a; b = i; eli = j; }
    public override void FillScope( LuaScope s ){
        e.FillScope( s );
        b.FillScope( s );
        eli.FillScope( s );
    }
}
%node SElse : stat
{
    exp e;
    block b1;
    block b2;
    public SElse( exp a , block i, block j ){ e = a; b1 = i; b2 = j; }
    public override void FillScope( LuaScope s ){
        e.FillScope( s );
        b1.FillScope( s );
        b2.FillScope( s );
    }
}

///////////////////////////// ELSEIF ////////////////////////////////////////
%symbol elseif {
	public elseif(){}
	public virtual void FillScope( LuaScope scope ){} 
}
%node If : elseif
{
    exp e;
    block b;
    public If( exp a , block i ){ e = a; b = i; }
    public override void FillScope( LuaScope s ){
        e.FillScope( s );
        b.FillScope( s );
    }
}
%node ElseIf : elseif
{
    exp e;
    block b;
    elseif eli;
    public ElseIf( exp a , block i, elseif j ){ e = a; b = i; eli = j; }
    public override void FillScope( LuaScope s ){
        e.FillScope( s );
        b.FillScope( s );
        eli.FillScope( s );
    }
}
%node Else : elseif
{
    exp e;
    block b1;
    block b2;
    public Else( exp a , block i, block j ){ e = a; b1 = i; b2 = j; }
    public override void FillScope( LuaScope s ){
        e.FillScope( s );
        b1.FillScope( s );
        b2.FillScope( s );
    }
}



////////////////////////////// ARGUMENT ///////////////////////////////////////
%symbol arg {
   private explist e;
   private tableconstructor t;
   public arg( tableconstructor a ){ t = a; }
   public arg( explist a ){ e = a; }
   public virtual void FillScope( LuaScope s ){
      if( e != null ){
         e.FillScope( s );
      }
      else if( t != null ){
         t.FillScope( s );
      }
   } 
}




///////////////////////////////////////////////////////////////////////////////
///////////////////////////// GRAMMAR PRODUCTIONS /////////////////////////////
///////////////////////////////////////////////////////////////////////////////

chunk			: stat:a												   %chunk( a )									
				| stat:a SEMICOLON										   %chunk( a )
				| stat:a chunk:b										   %chunk( a, b )
				| stat:a SEMICOLON chunk:b								   %chunk( a, b );
				
block			: chunk:a												   %block( a )
                |                                                          %block();

stat			: varlist:a ASSIGN explist:b							   %Assignment( a, b )													     									
				| prefixexp:a                                              %FunctionCall( a )	
				| DO block END											   %stat()
				| WHILE exp DO block END								   %stat()
				| WHILE exp DO END								           %stat()
				| REPEAT block UNTIL exp								   %stat()
				| IF exp:a THEN block:b END								   %SIf( a, b )
				| IF exp:a THEN block:b ELSEIF elseif:c END				   %SElseIf( a, b, c )
				| IF exp:a THEN block:b ELSE block:c END				   %SElse( a, b, c )
				| RETURN												   %stat()
				| RETURN explist:a										   %Retval( a )
				| BREAK													   %stat()
				| FOR NAME ASSIGN exp COMMA exp DO block END			   %stat()
				| FOR NAME ASSIGN exp COMMA exp COMMA exp DO block END	   %stat()
				| FOR namelist IN explist DO block END					   %stat()
				| FUNCTION funcname:a funcbody:b						   %FuncDecl( a, b )	
				| LOCAL FUNCTION NAME:s funcbody:b 						   %LocalFuncDecl( s, b )
				| LOCAL namelist										   %stat()
				| LOCAL namelist:a init:b								   %LocalInit( a, b );
				
elseif		    : exp:a THEN block:b ELSEIF elseif:c                       %ElseIf( a, b, c )                             
                | exp:a THEN block:b ELSE block:c                          %Else( a, b, c )
				| exp:a THEN block:b                                       %If( a, b ); 

fieldlist 	    : field:a                                                  %fieldlist( a )
				| field:a fieldsep fieldlist:b                             %fieldlist( a, b )
				| field:a fieldsep                                         %fieldlist( a );

tableconstructor : LBRACE RBRACE                                           %tableconstructor()
				 | LBRACE fieldlist:a RBRACE                               %tableconstructor( a );                        

parlist 		: NAME:s												   %parlist( s )
				| NAME:s COMMA parlist:a								   %parlist( s, a ) 
				| ELIPSE;
		   		
init			: ASSIGN explist:a                                         %init( a );  

explist		: exp:a COMMA explist:b                                        %explist( a,b )
			| exp:a                                                        %explist( a );
				
exp			: NIL:a                                                        %Atom( a ) 
            | FALSE:a                                                      %Atom( a ) 
            | TRUE:a                                                       %Atom( a ) 
            | NUMBER:a                                                     %Atom( a )
            | LITERAL:a                                                    %Atom( a )
			| function:a                                                   %exp( a ) 
			| prefixexp:a                                                  %exp( a ) 
			| tableconstructor:a                                           %ExpTableDec( a )
			| exp:a binop:b exp:c                                          %Binop( a,b,c ) 
			| unop:a exp:b                                                 %Unop( a,b );
				
functioncall   : prefixexp:a arg:b            							   %functioncall( a, b )
	   		   | prefixexp:a COLON NAME arg:b                              %functioncall( a, b );
				
prefixexp	: var:a                                                        %prefixexp( a )
			| functioncall:a                                               %prefixexp( a )   
			| LPAREN exp:a RPAREN                                          %prefixexp( a );

namelist	: NAME
			| NAME COMMA namelist;

varlist		: var:a COMMA varlist:b                                        %varlist( a, b )
			| var:a                                                        %varlist( a );            
				
var			: NAME:a                                                       %var( a ) 
			| prefixexp:a LBRACK exp:b RBRACK                              %TableRef( a, b ) 
			| prefixexp:a DOT NAME:b                                       %PackageRef( a, b );                                     

funcname 	: NAME DOT funcname
			| NAME COLON NAME
			| NAME:s												       %funcname( s );		
				
funcbody	: LPAREN RPAREN:b block:a END:c								   %funcbody( a, c, b )
			| LPAREN parlist:a RPAREN:d block:b END:c					   %funcbody( b, a, c, d )
			| LPAREN parlist:a RPAREN:b END:c                              %funcbody( a, b, c )
			| LPAREN RPAREN:a END:b                                        %funcbody( a, b );

function 	: FUNCTION funcbody:a                                          %function( a );

arg			: LPAREN RPAREN                                          
			| LPAREN explist:a RPAREN                                      %arg( a )
			| tableconstructor:a                                           %arg( a )
			| LITERAL;	
				
unop		: MINUS                                          
            | NOT
            | POUND;                                                  		
	
binop		: PLUS                                             
            | MINUS 
            | MULT 
            | MOD
            | DIVIDE 
            | EXP 
            | CONCAT
            | LT 
            | GT 
            | GE 
	 		| LE 
	 		| EQ 
	 		| AND
	 		| OR
	 		| NEQ;

fieldsep	: COMMA 
            | SEMICOLON;

field		: LBRACK exp:a RBRACK ASSIGN exp:b                            %FieldExpAssign( a, b )
			| NAME:a ASSIGN exp:b                                         %FieldAssign( a, b )
			| exp:a                                                       %field( a );
				

				
				
					
				 